# -*- coding: utf-8 -*-
"""Manage access to image data."""

from typing import Dict, List, Optional, Tuple

import csv
import os
import random
import regex


class ExperimentSessionInfo(dict):
    """Manage the access to image data.

    Mapping from room id to items left for this room.

    Args:
        path (str): Path to a valid csv file with two columns
            per row, containing the url of two paired up
            bits of HTML, one for each participant.
        n (int): Number of items presented per
            participant per room.
        shuffle (bool): Whether to randomly sample images or
            select them one by one as present in the file.
            If more items are present than required per room
            and participant, the selection is without replacement.
            Otherwise it is with replacement.
        seed (int): Use together with shuffle to
            make the item presentation process reproducible.
    """
    def __init__(self, path: Optional[str] = None, n: int = 1, shuffle: bool = False, seed=None) -> None:
        super().__init__()
        self._path = path
        self._n = n
        self._shuffle = shuffle

        # Remember that dicts are ordered since Python like... 3.5 or 3.6 or something
        self._items: Optional[dict] = None
        self._keys: Optional[List[Tuple[str, str]]] = None
        self._values: Optional[List[Tuple[str, str]]] = None
        if seed is not None:
            random.seed(seed)

    @property
    def n(self) -> int:
        return self._n

    def get_item_pairs(self, room_id, usernames: Tuple[str, str], filenames_only=False) -> List[Tuple[str, str]]:
        """Get the list of items for this pair of users.
        Args:
            room_id: Unique identifier of a task room.
            usernames: tuple of usernames we want to lookup pairs for
            filenames_only: flag to return filenames instead of datastructures with page contents loaded

        Returns:
            list of pairs of items for a given pair of users, either filenames or the full page contents as html
        """
        if self._items is None:
            # first time accessing the file
            # or a new access for each random sample (cf. end of `if self._shuffle` block below)
            self._items = self._read_all_items()
            self._keys = list(self._items.keys())
            self._values = list(self._items.values())
        source_list = self._keys if filenames_only else self._values
        _, _, list_num, _ = self._grab_data_from_username(usernames[0])

        starting_index = ((list_num % len(self._items)) * self._n) % len(self._items)
        ending_index = starting_index + self._n
        sample = source_list[starting_index:ending_index]
        if len(sample) < self._n:
            sample = sample + source_list[:self._n - len(sample)]

        if self._shuffle:
            random.shuffle(sample)
        self[room_id] = sample
        return sample

    def _read_all_items(self) -> Dict[Tuple[str, str], Tuple[str, str]]:
        """Load the html for each participant to view based on the input files."""
        with open(self._path, 'r', newline='') as csv_file:
            csv_reader = csv.reader(csv_file)
            items = {}
            for questioner_html_filepath, responder_html_filepath in csv_reader:
                with open(os.path.join(os.path.dirname(self._path), questioner_html_filepath), "r") as q_file:
                    q_data = q_file.read()
                with open(os.path.join(os.path.dirname(self._path), responder_html_filepath), "r") as r_file:
                    r_data = r_file.read()
                items[(questioner_html_filepath, responder_html_filepath)] = (q_data, r_data)
            return items

    @staticmethod
    def _grab_data_from_username(username: str) -> Tuple[str, str, int, str]:
        mo = regex.match("^\(([QR])([A-Za-z]+)([0-9]+)\) *([A-Za-z0-9 \-]+) *$", username)
        if mo:
            # role code (Q or R), experiment code (something alphabetical), and list number (integer value)
            return mo.group(1), mo.group(2), int(mo.group(3)), mo.group(4)
        else:
            raise ValueError(f"No match for regex in username: {username}")


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Generate item lists given lists of usernames.")
    parser.add_argument("exhibit_data", type=str,
                        help="CSV listing HTML file pairs for an experiment")
    parser.add_argument("num_items", type=int,
                        help="the number of items in each list")
    parser.add_argument("participant_tokens", type=str,
                        help="CSV listing pairs of participant tokens generated by slurk")

    parser.add_argument("--experiment_id", type=str, default="A",
                        help="an alphabetical code for this experiment")
    parser.add_argument("--questioner_label", type=str, default="Neach-tadhail",
                        help="username to provide after the user ID code for questioners")
    parser.add_argument("--responder_label", type=str, default="Neach-freagairt",
                        help="username to provide after the user ID code for responders")
    parser.add_argument("--protocol", type=str, default="http")
    parser.add_argument("--hostname", type=str, default="localhost")
    parser.add_argument("--port", type=int)
    parser.add_argument("--prefix", type=str, default="/gaelic")

    args = parser.parse_args()
    session_info = ExperimentSessionInfo(args.exhibit_data, args.num_items)

    host_and_port = f"{args.hostname}:{args.port}" if args.port else args.hostname
    url = f"{args.protocol}://{host_and_port}{args.prefix}/"

    with open(args.participant_tokens, 'r', newline='') as participant_tokens_file:
        reader = csv.reader(participant_tokens_file)
        with open('tmp.out.csv', 'w') as output_file:
            for num, tokens in enumerate(reader):
                questioner_name = f"(Q{args.experiment_id}{num:03d}) {args.questioner_label}"
                responder_name = f"(R{args.experiment_id}{num:03d}) {args.responder_label}"
                item_pairs = session_info.get_item_pairs(f"{num}", (questioner_name, responder_name), filenames_only=True)
                # TODO in the future we could use urllib to encode the URLs
                # for our current purposes, we just replace spaces with %20
                questioner_url = f"{url}/login/?token={tokens[0]}&name={questioner_name.replace(' ', '%20')}"
                print(questioner_url)
                responder_url = f"{url}/login/?token={tokens[1]}&name={responder_name.replace(' ', '%20')}"
                print(responder_url)
                sample_string = '\t'.join([str(x) for x in item_pairs])
                output_file.write(f"{questioner_name}\t{questioner_url}\t{responder_name}\t{responder_url}\t{sample_string}\n")
